<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>KnowledgeCacheService.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Coverage with Unit Tests</a> &gt; <a href="../index.html" class="el_bundle">service</a> &gt; <a href="index.source.html" class="el_package">org.ehrbase.service</a> &gt; <span class="el_source">KnowledgeCacheService.java</span></div><h1>KnowledgeCacheService.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2019 vitasystems GmbH and Hannover Medical School.
 *
 * This file is part of project EHRbase
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.ehrbase.service;

import java.io.IOException;
import java.io.InputStream;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;
import javax.annotation.PostConstruct;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.lang3.tuple.Triple;
import org.apache.xmlbeans.XmlException;
import org.ehrbase.api.exception.InvalidApiParameterException;
import org.ehrbase.api.exception.StateConflictException;
import org.ehrbase.api.service.TenantService;
import org.ehrbase.api.tenant.Tenant;
import org.ehrbase.aql.containment.JsonPathQueryResult;
import org.ehrbase.aql.containment.TemplateIdAqlTuple;
import org.ehrbase.aql.sql.queryimpl.ItemInfo;
import org.ehrbase.cache.CacheOptions;
import org.ehrbase.ehr.knowledge.I_KnowledgeCache;
import org.ehrbase.ehr.knowledge.TemplateMetaData;
import org.ehrbase.openehr.sdk.webtemplate.model.WebTemplate;
import org.ehrbase.openehr.sdk.webtemplate.model.WebTemplateNode;
import org.ehrbase.openehr.sdk.webtemplate.parser.NodeId;
import org.ehrbase.openehr.sdk.webtemplate.parser.OPTParser;
import org.ehrbase.tenant.DefaultTenantAuthentication;
import org.ehrbase.util.TemplateUtils;
import org.openehr.schemas.v1.OPERATIONALTEMPLATE;
import org.openehr.schemas.v1.TemplateDocument;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

/**
 * Look up and caching for archetypes, openEHR showTemplates and Operational Templates. Search in
 * path defined as
 *
 * &lt;ul&gt;
 *   &lt;li&gt;1. System environment ETHERCIS_ARCHETYPE_DIR, ETHERCIS_TEMPLATE_DIR, ETHERCIS_OPT_DIR
 *   &lt;li&gt;2. Application path %USER_HOME%/.ethercis/archetype, %USER_HOME%/.ethercis/template,
 *       %USER_HOME%/.ethercis/opt
 *   &lt;li&gt;3. User can also include a source directory by invoking addXYZPath method
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The resources extensions are defined by the following default:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;ADL: archetype
 *   &lt;li&gt;OET: openehr template
 *   &lt;li&gt;OPT: operational template
 * &lt;/ul&gt;
 *
 * @author C. Chevalley
 */
@Service
// This service is not @Transactional since we only want to get DB connections when we really need to and an already
// running transaction is propagated anyway
public class KnowledgeCacheService implements I_KnowledgeCache, IntrospectService {

    public static final String ELEMENT = &quot;ELEMENT&quot;;
<span class="fc" id="L98">    private final Logger log = LoggerFactory.getLogger(this.getClass());</span>

    private final TemplateStorage templateStorage;
    private final CacheOptions cacheOptions;

    private final Cache jsonPathQueryResultCache;
    private final Cache webTemplateCache;
    private final Cache fieldCache;
    private final Cache multivaluedCache;
    private final TenantService tenantService;

    // index val to val
<span class="fc" id="L110">    private final Map&lt;CacheKey&lt;UUID&gt;, String&gt; idxCacheUuidToTemplateId = new ConcurrentHashMap&lt;&gt;();</span>
    // index val to val
<span class="fc" id="L112">    private final Map&lt;String, CacheKey&lt;UUID&gt;&gt; idxCacheTemplateIdToUuid = new ConcurrentHashMap&lt;&gt;();</span>
    private final Cache /*&lt;UUID, ConceptValue&gt;*/ conceptById;
    private final Cache /*&lt;Pair&lt;Integer, String&gt;, ConceptValue&gt;*/ conceptByConceptId;
    private final Cache /*&lt;Pair&lt;String, String&gt;, ConceptValue&gt;*/ conceptByDescription;
    private final Cache /*&lt;String, TerritoryValue&gt;*/ territoryCache;
    private final Cache /*&lt;String, LanguageValue&gt;*/ languageCache;

    @Value(&quot;${system.allow-template-overwrite:false}&quot;)
    private boolean allowTemplateOverwrite;

<span class="fc" id="L122">    public KnowledgeCacheService(</span>
            TemplateStorage templateStorage,
            CacheManager cacheManager,
            CacheOptions cacheOptions,
            TenantService tenantService) {

<span class="fc" id="L128">        this.templateStorage = templateStorage;</span>
<span class="fc" id="L129">        this.cacheOptions = cacheOptions;</span>
<span class="fc" id="L130">        this.tenantService = tenantService;</span>

<span class="fc" id="L132">        webTemplateCache = cacheManager.getCache(CacheOptions.INTROSPECT_CACHE);</span>
<span class="fc" id="L133">        jsonPathQueryResultCache = cacheManager.getCache(CacheOptions.QUERY_CACHE);</span>
<span class="fc" id="L134">        fieldCache = cacheManager.getCache(CacheOptions.FIELDS_CACHE);</span>
<span class="fc" id="L135">        multivaluedCache = cacheManager.getCache(CacheOptions.MULTI_VALUE_CACHE);</span>
<span class="fc" id="L136">        conceptById = cacheManager.getCache(CacheOptions.CONCEPT_CACHE_ID);</span>
<span class="fc" id="L137">        conceptByConceptId = cacheManager.getCache(CacheOptions.CONCEPT_CACHE_CONCEPT_ID);</span>
<span class="fc" id="L138">        conceptByDescription = cacheManager.getCache(CacheOptions.CONCEPT_CACHE_DESCRIPTION);</span>

<span class="fc" id="L140">        territoryCache = cacheManager.getCache(CacheOptions.TERRITORY_CACHE);</span>
<span class="fc" id="L141">        languageCache = cacheManager.getCache(CacheOptions.LANGUAGE_CACHE);</span>
<span class="fc" id="L142">    }</span>

    @PostConstruct
    void init() throws InterruptedException {

<span class="nc" id="L147">        initializeCaches(cacheOptions.isPreInitialize());</span>
<span class="nc" id="L148">    }</span>

    // fetch all tenants and initialize the caches for each tenant seperatly
<span class="fc" id="L151">    private static final int NUM_OF_PROC = Runtime.getRuntime().availableProcessors();</span>
<span class="fc" id="L152">    private static final ExecutorService execService = Executors.newFixedThreadPool(NUM_OF_PROC);</span>

    private abstract static class SecCtxAwareRunnable implements Runnable {
        private Authentication auth;

<span class="nc" id="L157">        private SecCtxAwareRunnable(Authentication auth) {</span>
<span class="nc" id="L158">            this.auth = auth;</span>
<span class="nc" id="L159">        }</span>

        public void run() {
<span class="nc" id="L162">            SecurityContextHolder.getContext().setAuthentication(auth);</span>
<span class="nc" id="L163">            doRun();</span>
<span class="nc" id="L164">        }</span>

        abstract void doRun();
    }

    private static final String ERR_CACHE_ERROR = &quot;An error occurred while caching template: {}&quot;;
<span class="fc" id="L170">    private static final String ERR_GEN_ERROR = &quot;An error occurred while calculating queries for template: {}&quot;;</span>

    private Future&lt;?&gt; initCachePerTenant(String tenantId) {
<span class="nc" id="L173">        SecCtxAwareRunnable runMe = new SecCtxAwareRunnable(DefaultTenantAuthentication.of(tenantId)) {</span>
            void doRun() {
<span class="nc" id="L175">                Set&lt;String&gt; templateIds = new HashSet&lt;&gt;();</span>

<span class="nc" id="L177">                listAllOperationalTemplates().forEach(metadata -&gt; {</span>
<span class="nc" id="L178">                    var template = metadata.getOperationaltemplate();</span>
<span class="nc" id="L179">                    var templateId = TemplateUtils.getTemplateId(template);</span>
<span class="nc" id="L180">                    templateIds.add(templateId);</span>
                    try {
<span class="nc" id="L182">                        putIntoCache(template, tenantService.getCurrentSysTenant());</span>
<span class="nc" id="L183">                    } catch (RuntimeException e) {</span>
<span class="nc" id="L184">                        log.error(ERR_CACHE_ERROR, templateId, e);</span>
                    }
<span class="nc" id="L186">                });</span>

<span class="nc" id="L188">                templateIds.forEach(templateId -&gt; {</span>
                    try {
<span class="nc" id="L190">                        preBuildQueries(templateId, cacheOptions.isPreBuildQueries());</span>
<span class="nc" id="L191">                    } catch (RuntimeException e) {</span>
<span class="nc" id="L192">                        log.error(ERR_GEN_ERROR, templateId, e);</span>
                    }
<span class="nc" id="L194">                });</span>
<span class="nc" id="L195">            }</span>
        };

<span class="nc" id="L198">        return execService.submit(runMe);</span>
    }

    private void initializeCaches(boolean init) throws InterruptedException {
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (!init) return;</span>

<span class="nc" id="L204">        List&lt;Tenant&gt; tenants = tenantService.getAll();</span>
<span class="nc" id="L205">        List&lt;Future&lt;?&gt;&gt; collect = tenants.stream()</span>
<span class="nc" id="L206">                .map(Tenant::getTenantId)</span>
<span class="nc" id="L207">                .map(this::initCachePerTenant)</span>
<span class="nc" id="L208">                .collect(Collectors.toList());</span>

<span class="nc bnc" id="L210" title="All 2 branches missed.">        for (int i = 0; i &lt; 16; ) {</span>
<span class="nc bnc" id="L211" title="All 4 branches missed.">            boolean res = collect.stream().map(Future::isDone).reduce(true, (a, b) -&gt; a &amp;&amp; b);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (res) return;</span>
<span class="nc" id="L213">            i = Math.max(1, 2 * i);</span>
<span class="nc" id="L214">            Thread.sleep(i * 1000L);</span>
        }

<span class="nc" id="L217">        collect.forEach(f -&gt; {</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">            if (!f.isDone()) f.cancel(false);</span>
<span class="nc" id="L219">        });</span>
<span class="nc" id="L220">    }</span>

    @Override
    public Set&lt;String&gt; getAllTemplateIds() {
<span class="fc" id="L224">        return templateStorage.findAllTemplateIds();</span>
    }

    @Override
    public String addOperationalTemplate(InputStream inputStream) {
<span class="fc" id="L229">        OPERATIONALTEMPLATE template = buildOperationalTemplate(inputStream);</span>
<span class="fc" id="L230">        return addOperationalTemplateIntern(template, false);</span>
    }

    private OPERATIONALTEMPLATE buildOperationalTemplate(InputStream content) {
        try {
<span class="fc" id="L235">            TemplateDocument document = TemplateDocument.Factory.parse(content);</span>
<span class="fc" id="L236">            return document.getTemplate();</span>
<span class="nc" id="L237">        } catch (XmlException | IOException e) {</span>
<span class="nc" id="L238">            throw new InvalidApiParameterException(e.getMessage());</span>
        }
    }

    @Override
    public String addOperationalTemplate(OPERATIONALTEMPLATE template) {
<span class="nc" id="L244">        return addOperationalTemplateIntern(template, false);</span>
    }

    private String addOperationalTemplateIntern(OPERATIONALTEMPLATE template, boolean overwrite) {
<span class="fc" id="L248">        validateTemplate(template);</span>

        String templateId;
        try {
<span class="fc" id="L252">            templateId = TemplateUtils.getTemplateId(template);</span>
<span class="pc" id="L253">        } catch (IllegalArgumentException a) {</span>
<span class="nc" id="L254">            throw new InvalidApiParameterException(&quot;Invalid template input content&quot;);</span>
        }

        // pre-check: if already existing throw proper exception
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (!allowTemplateOverwrite</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                &amp;&amp; !overwrite</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">                &amp;&amp; retrieveOperationalTemplate(templateId).isPresent()) {</span>
<span class="nc" id="L261">            throw new StateConflictException(</span>
<span class="nc" id="L262">                    &quot;Operational template with this template ID already exists: &quot; + templateId);</span>
        } else {
<span class="fc" id="L264">            invalidateCache(template);</span>
        }

<span class="fc" id="L267">        templateStorage.storeTemplate(template, tenantService.getCurrentSysTenant());</span>
<span class="fc" id="L268">        putIntoCache(template, tenantService.getCurrentSysTenant());</span>

<span class="fc" id="L270">        preBuildQueries(templateId, cacheOptions.isPreBuildQueries());</span>

<span class="fc" id="L272">        return templateId;</span>
    }

    private void preBuildQueries(String templateId, boolean preBuild) {
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if (!preBuild) return;</span>

<span class="nc" id="L278">        getQueryOptMetaData(templateId).findAllContainmentCombinations().stream()</span>
<span class="nc bnc" id="L279" title="All 4 branches missed.">                .filter(nodeIds -&gt; !nodeIds.isEmpty() &amp;&amp; nodeIds.size() &lt;= cacheOptions.getPreBuildQueriesDepth())</span>
<span class="nc" id="L280">                .forEach(nodeIds -&gt; execService.submit(</span>
<span class="nc" id="L281">                        new SecCtxAwareRunnable(</span>
<span class="nc" id="L282">                                SecurityContextHolder.getContext().getAuthentication()) {</span>
                            void doRun() {
<span class="nc" id="L284">                                resolveForTemplate(templateId, nodeIds);</span>
<span class="nc" id="L285">                            }</span>
<span class="nc" id="L286">                        }));</span>
<span class="nc" id="L287">    }</span>

    private void putIntoCache(OPERATIONALTEMPLATE template, Short sysTenant) {
<span class="fc" id="L290">        var templateId = TemplateUtils.getTemplateId(template);</span>
<span class="fc" id="L291">        var uid = TemplateUtils.getUid(template);</span>

        try {
<span class="fc" id="L294">            idxCacheUuidToTemplateId.put(CacheKey.of(uid, sysTenant), templateId);</span>
<span class="fc" id="L295">            idxCacheTemplateIdToUuid.put(templateId, CacheKey.of(uid, sysTenant));</span>

<span class="fc" id="L297">            getQueryOptMetaData(templateId);</span>
<span class="pc" id="L298">        } catch (RuntimeException e) {</span>
<span class="nc" id="L299">            log.error(&quot;Invalid template {}&quot;, templateId);</span>
<span class="nc" id="L300">            invalidateCache(template);</span>
<span class="nc" id="L301">            throw e;</span>
        }
<span class="fc" id="L303">    }</span>

    public String adminUpdateOperationalTemplate(InputStream content) {
<span class="nc" id="L306">        OPERATIONALTEMPLATE template = buildOperationalTemplate(content);</span>
<span class="nc" id="L307">        return addOperationalTemplateIntern(template, true);</span>
    }

    // invalidates some derived caches like the queryOptMetaDataCache which depend on the template
    private void invalidateCache(OPERATIONALTEMPLATE template) {
        // invalidate the cache for this template
<span class="fc" id="L313">        webTemplateCache.evict(CacheKey.of(TemplateUtils.getUid(template), tenantService.getCurrentSysTenant()));</span>

<span class="fc" id="L315">        jsonPathQueryResultCache.invalidate();</span>
<span class="fc" id="L316">        fieldCache.invalidate();</span>
<span class="fc" id="L317">        multivaluedCache.invalidate();</span>
<span class="fc" id="L318">    }</span>

    @Override
    public List&lt;TemplateMetaData&gt; listAllOperationalTemplates() {
<span class="fc" id="L322">        return templateStorage.listAllOperationalTemplates();</span>
    }

    @Override
    public Optional&lt;OPERATIONALTEMPLATE&gt; retrieveOperationalTemplate(String key) {
<span class="fc" id="L327">        log.debug(&quot;retrieveOperationalTemplate({})&quot;, key);</span>
<span class="fc" id="L328">        return Optional.ofNullable(getOperationaltemplateFromFileStorage(key));</span>
    }

    @Override
    public Optional&lt;OPERATIONALTEMPLATE&gt; retrieveOperationalTemplate(UUID uuid) {
<span class="fc" id="L333">        return Optional.ofNullable(findTemplateIdByUuid(uuid)).flatMap(key -&gt; retrieveOperationalTemplate(key));</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean deleteOperationalTemplate(OPERATIONALTEMPLATE template) {
        // Remove template from storage
<span class="nc" id="L342">        boolean deleted =</span>
<span class="nc" id="L343">                this.templateStorage.deleteTemplate(template.getTemplateId().getValue());</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (deleted) {</span>
            // Remove template from caches
<span class="nc" id="L347">            invalidateCache(template);</span>
        }

<span class="nc" id="L350">        return deleted;</span>
    }

    private String findTemplateIdByUuid(UUID uuid) {
<span class="fc" id="L354">        return idxCacheUuidToTemplateId.computeIfAbsent(</span>
<span class="pc" id="L355">                CacheKey.of(uuid, tenantService.getCurrentSysTenant()), ck -&gt; listAllOperationalTemplates().stream()</span>
<span class="nc" id="L356">                        .filter(t -&gt; t.getErrorList().isEmpty())</span>
<span class="nc" id="L357">                        .filter(t -&gt; t.getOperationaltemplate()</span>
<span class="nc" id="L358">                                .getUid()</span>
<span class="nc" id="L359">                                .getValue()</span>
<span class="nc" id="L360">                                .equals(ck.getVal().toString()))</span>
<span class="nc" id="L361">                        .map(t -&gt; t.getOperationaltemplate().getTemplateId().getValue())</span>
<span class="nc" id="L362">                        .findFirst()</span>
<span class="nc" id="L363">                        .orElse(null));</span>
    }

    private UUID findUuidByTemplateId(String templateId) {
<span class="fc" id="L367">        return idxCacheTemplateIdToUuid</span>
<span class="fc" id="L368">                .computeIfAbsent(templateId, id -&gt; {</span>
<span class="nc" id="L369">                    OPERATIONALTEMPLATE templ = retrieveOperationalTemplate(id)</span>
<span class="nc" id="L370">                            .orElseThrow(() -&gt;</span>
<span class="nc" id="L371">                                    new IllegalArgumentException(String.format(&quot;Unknown template %s&quot;, templateId)));</span>
<span class="nc" id="L372">                    return CacheKey.of(UUID.fromString(templ.getUid().getValue()), tenantService.getCurrentSysTenant());</span>
                })
<span class="fc" id="L374">                .getVal();</span>
    }

    @Override
    public WebTemplate getQueryOptMetaData(UUID uuid) {
<span class="fc" id="L379">        CacheKey&lt;UUID&gt; ck = CacheKey.of(uuid, tenantService.getCurrentSysTenant());</span>
<span class="fc" id="L380">        return webTemplateCache.get(ck, () -&gt; buildQueryOptMetaData(uuid));</span>
    }

    @Override
    public WebTemplate getQueryOptMetaData(String templateId) {
<span class="fc" id="L385">        return getQueryOptMetaData(findUuidByTemplateId(templateId));</span>
    }

    private WebTemplate buildQueryOptMetaData(UUID uuid) {
        Optional&lt;OPERATIONALTEMPLATE&gt; operationaltemplate;

        try {
<span class="fc" id="L392">            operationaltemplate = retrieveOperationalTemplate(uuid);</span>
<span class="pc" id="L393">        } catch (Exception e) {</span>
<span class="nc" id="L394">            log.warn(e.getMessage(), e);</span>
<span class="nc" id="L395">            operationaltemplate = Optional.empty();</span>
        }

<span class="fc" id="L398">        return operationaltemplate</span>
<span class="fc" id="L399">                .map(this::buildQueryOptMetaData)</span>
<span class="pc" id="L400">                .orElseThrow(() -&gt; new IllegalArgumentException(</span>
<span class="nc" id="L401">                        &quot;Could not retrieve  knowledgeCacheService.getKnowledgeCache() cache for template Uid:&quot;</span>
<span class="nc" id="L402">                                + uuid));</span>
    }

    private WebTemplate buildQueryOptMetaData(OPERATIONALTEMPLATE operationaltemplate) {
<span class="fc" id="L406">        log.info(&quot;Updating WebTemplate cache for template: {}&quot;, TemplateUtils.getTemplateId(operationaltemplate));</span>
        try {
<span class="fc" id="L408">            return new OPTParser(operationaltemplate).parse();</span>
<span class="nc" id="L409">        } catch (Exception e) {</span>
<span class="nc" id="L410">            throw new IllegalArgumentException(String.format(&quot;Invalid template: %s&quot;, e.getMessage()));</span>
        }
    }

    /**
     * Helper function to retrieve the operational template from file storage and put it into the
     * cache. For instance, to handle first time access to an operational template before it was
     * written to cache already.
     *
     * @param filename of the OPT file in storage
     * @return The operational template or null.
     */
    private OPERATIONALTEMPLATE getOperationaltemplateFromFileStorage(String filename) {
<span class="fc" id="L423">        var template = templateStorage.readOperationaltemplate(filename);</span>
<span class="fc" id="L424">        template.ifPresent(existingTemplate -&gt; idxCacheUuidToTemplateId.put(</span>
<span class="fc" id="L425">                CacheKey.of(TemplateUtils.getUid(existingTemplate), tenantService.getCurrentSysTenant()), filename));</span>
<span class="fc" id="L426">        return template.orElse(null);</span>
    }

    public int deleteAllOperationalTemplates() {
        // Get all operational templates
<span class="nc" id="L431">        List&lt;TemplateMetaData&gt; templateList = this.templateStorage.listAllOperationalTemplates();</span>
        // If list is empty no deletion required
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (templateList.isEmpty()) {</span>
<span class="nc" id="L434">            return 0;</span>
        }
<span class="nc" id="L436">        int deleted = 0;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        for (TemplateMetaData metaData : templateList) {</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (deleteOperationalTemplate(metaData.getOperationaltemplate())) {</span>
<span class="nc" id="L439">                deleted++;</span>
            }
        }

<span class="nc" id="L443">        return deleted;</span>
    }

    @Override
    public JsonPathQueryResult resolveForTemplate(String templateId, Collection&lt;NodeId&gt; nodeIds) {
<span class="fc" id="L448">        Triple&lt;String, Short, Collection&lt;NodeId&gt;&gt; key =</span>
<span class="fc" id="L449">                Triple.of(templateId, tenantService.getCurrentSysTenant(), nodeIds);</span>
<span class="fc" id="L450">        JsonPathQueryResult jsonPathQueryResult =</span>
<span class="fc" id="L451">                jsonPathQueryResultCache.get(key, () -&gt; createJsonPathQueryResult(key));</span>

<span class="fc bfc" id="L453" title="All 2 branches covered.">        return jsonPathQueryResult.getTemplateId() != null ? jsonPathQueryResult : null;</span>
    }

    private JsonPathQueryResult createJsonPathQueryResult(Triple&lt;String, Short, Collection&lt;NodeId&gt;&gt; key) {
        JsonPathQueryResult jsonPathQueryResult;
<span class="fc" id="L458">        WebTemplate webTemplate = getQueryOptMetaData(key.getLeft());</span>
<span class="fc" id="L459">        List&lt;WebTemplateNode&gt; webTemplateNodeList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L460">        webTemplateNodeList.add(webTemplate.getTree());</span>

<span class="fc bfc" id="L462" title="All 2 branches covered.">        for (NodeId nodeId : key.getRight()) {</span>
<span class="fc" id="L463">            webTemplateNodeList = webTemplateNodeList.stream()</span>
<span class="fc" id="L464">                    .map(n -&gt; n.findMatching(f -&gt; {</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">                        if (f.getNodeId() == null) return false;</span>
                        // compere only classname
<span class="fc bfc" id="L467" title="All 2 branches covered.">                        else if (nodeId.getNodeId() == null)</span>
<span class="fc" id="L468">                            return nodeId.getClassName().equals(new NodeId(f.getNodeId()).getClassName());</span>
<span class="fc" id="L469">                        else return nodeId.equals(new NodeId(f.getNodeId()));</span>
<span class="fc" id="L470">                    }))</span>
<span class="fc" id="L471">                    .flatMap(List::stream)</span>
<span class="fc" id="L472">                    .collect(Collectors.toList());</span>
        }

<span class="fc" id="L475">        Set&lt;String&gt; uniquePaths = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L476">        webTemplateNodeList.stream().map(n -&gt; n.getAqlPath(false)).forEach(uniquePaths::add);</span>

<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (!uniquePaths.isEmpty()) {</span>
<span class="fc" id="L479">            jsonPathQueryResult = new JsonPathQueryResult(key.getLeft(), uniquePaths);</span>
<span class="fc" id="L480">        } else {</span>
            // dummy result since null can not be path of a cache
<span class="fc" id="L482">            jsonPathQueryResult = new JsonPathQueryResult(null, Collections.emptyMap());</span>
        }
<span class="fc" id="L484">        return jsonPathQueryResult;</span>
    }

    @Override
    public ItemInfo getInfo(String templateId, String aql) {
<span class="fc" id="L489">        TemplateIdAqlTuple key = new TemplateIdAqlTuple(templateId, aql, tenantService.getCurrentSysTenant());</span>
<span class="fc" id="L490">        return fieldCache.get(key, () -&gt; createItemInfo(key));</span>
    }

    private ItemInfo createItemInfo(TemplateIdAqlTuple key) {
<span class="fc" id="L494">        WebTemplate webTemplate = getQueryOptMetaData(key.getTemplateId());</span>
<span class="fc" id="L495">        String keyAql = key.getAql();</span>
<span class="fc" id="L496">        Optional&lt;WebTemplateNode&gt; node = webTemplate.findByAqlPath(keyAql);</span>
        final String type;
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if (node.isEmpty()) {</span>
<span class="nc" id="L499">            type = null;</span>
<span class="pc bfc" id="L500" title="All 2 branches covered.">        } else if (node.get().getRmType().equals(ELEMENT)) {</span>
            // for element unwrap
<span class="fc" id="L502">            type = node.get().getChildren().get(0).getRmType();</span>
<span class="fc" id="L503">        } else {</span>
<span class="fc" id="L504">            type = node.get().getRmType();</span>
        }
        String category;

<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        if (node.isEmpty()) {</span>
<span class="nc" id="L509">            category = null;</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">        } else if (keyAql.endsWith(&quot;/value&quot;)) {</span>
            // for element unwrap
<span class="nc" id="L512">            category = webTemplate</span>
<span class="nc" id="L513">                    .findByAqlPath(keyAql.replace(&quot;/value&quot;, &quot;&quot;))</span>
<span class="nc" id="L514">                    .filter(n -&gt; n.getRmType().equals(ELEMENT))</span>
<span class="nc" id="L515">                    .map(n -&gt; ELEMENT)</span>
<span class="nc" id="L516">                    .orElse(&quot;DATA_STRUCTURE&quot;);</span>
<span class="nc" id="L517">        } else {</span>
<span class="fc" id="L518">            category = &quot;DATA_STRUCTURE&quot;;</span>
        }

<span class="fc" id="L521">        return new ItemInfo(type, category);</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;String&gt; multiValued(String templateId) {
<span class="fc" id="L527">        return multivaluedCache.get(</span>
<span class="fc" id="L528">                CacheKey.of(templateId, tenantService.getCurrentSysTenant()),</span>
<span class="fc" id="L529">                () -&gt; getQueryOptMetaData(templateId).multiValued().stream()</span>
<span class="fc" id="L530">                        .map(webTemplateNode -&gt; webTemplateNode.getAqlPath(false))</span>
<span class="fc" id="L531">                        .collect(Collectors.toList()));</span>
    }

    @Override
    public I_KnowledgeCache getKnowledge() {
<span class="nc" id="L536">        return this;</span>
    }

    /**
     * Validates that the given template is valid and supported by EHRbase.
     *
     * @param template the template to validate
     */
    private void validateTemplate(OPERATIONALTEMPLATE template) {
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">        if (template == null) {</span>
<span class="nc" id="L546">            throw new InvalidApiParameterException(&quot;Could not parse input template&quot;);</span>
        }

<span class="pc bpc" id="L549" title="2 of 4 branches missed.">        if (template.getConcept() == null || template.getConcept().isEmpty()) {</span>
<span class="nc" id="L550">            throw new IllegalArgumentException(&quot;Supplied template has nil or empty concept&quot;);</span>
        }

<span class="pc bpc" id="L553" title="2 of 4 branches missed.">        if (template.getLanguage() == null || template.getLanguage().isNil()) {</span>
<span class="nc" id="L554">            throw new IllegalArgumentException(&quot;Supplied template has nil or empty language&quot;);</span>
        }

<span class="pc bpc" id="L557" title="2 of 4 branches missed.">        if (template.getDefinition() == null || template.getDefinition().isNil()) {</span>
<span class="nc" id="L558">            throw new IllegalArgumentException(&quot;Supplied template has nil or empty definition&quot;);</span>
        }

<span class="pc bpc" id="L561" title="2 of 4 branches missed.">        if (template.getDescription() == null || !template.getDescription().validate()) {</span>
<span class="nc" id="L562">            throw new IllegalArgumentException(&quot;Supplied template has nil or empty description&quot;);</span>
        }

<span class="fc bfc" id="L565" title="All 2 branches covered.">        if (!TemplateUtils.isSupported(template)) {</span>
<span class="fc" id="L566">            throw new IllegalArgumentException(MessageFormat.format(</span>
<span class="fc" id="L567">                    &quot;The supplied template is not supported (unsupported types: {0})&quot;,</span>
<span class="fc" id="L568">                    String.join(&quot;,&quot;, TemplateUtils.UNSUPPORTED_RM_TYPES)));</span>
        }
<span class="fc" id="L570">    }</span>

    @Override
    public ConceptValue getConceptByConceptId(
            int conceptId, String language, BiFunction&lt;Integer, String, ConceptValue&gt; provider) {
<span class="nc" id="L575">        ConceptValue concept = conceptByConceptId.get(Pair.of(conceptId, language), ConceptValue.class);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">        if (concept == null) {</span>
<span class="nc" id="L577">            concept = provider.apply(conceptId, language);</span>
<span class="nc" id="L578">            addConceptToCaches(concept);</span>
        }
<span class="nc" id="L580">        return concept;</span>
    }

    @Override
    public ConceptValue getConceptById(UUID id, Function&lt;UUID, ConceptValue&gt; provider) {
<span class="nc" id="L585">        ConceptValue concept = conceptById.get(id, ConceptValue.class);</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">        if (concept == null) {</span>
<span class="nc" id="L587">            concept = provider.apply(id);</span>
<span class="nc" id="L588">            addConceptToCaches(concept);</span>
        }
<span class="nc" id="L590">        return concept;</span>
    }

    @Override
    public ConceptValue getConceptByDescription(
            String description, String language, BiFunction&lt;String, String, ConceptValue&gt; provider) {
<span class="nc" id="L596">        ConceptValue concept = conceptByDescription.get(Pair.of(description, language), ConceptValue.class);</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">        if (concept == null) {</span>
<span class="nc" id="L598">            concept = provider.apply(description, language);</span>
<span class="nc" id="L599">            addConceptToCaches(concept);</span>
        }
<span class="nc" id="L601">        return concept;</span>
    }

    private void addConceptToCaches(ConceptValue concept) {
<span class="nc" id="L605">        conceptById.put(concept.getId(), concept);</span>
<span class="nc" id="L606">        conceptByConceptId.put(Pair.of(concept.getConceptId(), concept.getLanguage()), concept);</span>
<span class="nc" id="L607">        conceptByDescription.put(Pair.of(concept.getDescription(), concept.getLanguage()), concept);</span>
<span class="nc" id="L608">    }</span>

    @Override
    public TerritoryValue getTerritoryCodeByTwoLetterCode(
            String territoryAsString, Function&lt;String, TerritoryValue&gt; provider) {
<span class="nc" id="L613">        return territoryCache.get(territoryAsString, () -&gt; provider.apply(territoryAsString));</span>
    }

    @Override
    public LanguageValue getLanguageByCode(String languageCode, Function&lt;String, LanguageValue&gt; provider) {
<span class="nc" id="L618">        return languageCache.get(languageCode, () -&gt; provider.apply(languageCode));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>