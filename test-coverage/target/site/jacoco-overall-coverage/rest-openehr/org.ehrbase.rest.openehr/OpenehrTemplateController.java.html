<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>OpenehrTemplateController.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Overall Coverage</a> &gt; <a href="../index.html" class="el_bundle">rest-openehr</a> &gt; <a href="index.source.html" class="el_package">org.ehrbase.rest.openehr</a> &gt; <span class="el_source">OpenehrTemplateController.java</span></div><h1>OpenehrTemplateController.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2019 vitasystems GmbH and Hannover Medical School.
 *
 * This file is part of project EHRbase
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.ehrbase.rest.openehr;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.http.MediaType.APPLICATION_XML;

import com.nedap.archie.rm.composition.Composition;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Supplier;
import org.apache.xmlbeans.XmlException;
import org.ehrbase.api.annotations.TenantAware;
import org.ehrbase.api.authorization.EhrbaseAuthorization;
import org.ehrbase.api.authorization.EhrbasePermission;
import org.ehrbase.api.definitions.OperationalTemplateFormat;
import org.ehrbase.api.exception.InternalServerException;
import org.ehrbase.api.exception.InvalidApiParameterException;
import org.ehrbase.api.exception.NotAcceptableException;
import org.ehrbase.api.service.CompositionService;
import org.ehrbase.api.service.TemplateService;
import org.ehrbase.openehr.sdk.response.dto.ResponseData;
import org.ehrbase.openehr.sdk.response.dto.TemplateResponseData;
import org.ehrbase.openehr.sdk.response.dto.TemplatesResponseData;
import org.ehrbase.openehr.sdk.response.dto.ehrscape.CompositionDto;
import org.ehrbase.openehr.sdk.response.dto.ehrscape.CompositionFormat;
import org.ehrbase.openehr.sdk.response.dto.ehrscape.TemplateMetaDataDto;
import org.ehrbase.rest.BaseController;
import org.ehrbase.rest.openehr.specification.TemplateApiSpecification;
import org.ehrbase.rest.util.InternalResponse;
import org.openehr.schemas.v1.TemplateDocument;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

/**
 * Controller for /template resource as part of the Definitions sub-API of the openEHR REST API
 */
@TenantAware
@RestController
@RequestMapping(
        path = BaseController.API_CONTEXT_PATH_WITH_VERSION + &quot;/definition/template&quot;,
        produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
public class OpenehrTemplateController extends BaseController implements TemplateApiSpecification {

    protected static final String ADL_1_4 = &quot;adl1.4&quot;;
    private final TemplateService templateService;
    private final CompositionService compositionService;

    @Autowired
<span class="nc" id="L84">    public OpenehrTemplateController(TemplateService templateService, CompositionService compositionService) {</span>
<span class="nc" id="L85">        this.templateService = Objects.requireNonNull(templateService);</span>
<span class="nc" id="L86">        this.compositionService = Objects.requireNonNull(compositionService);</span>
<span class="nc" id="L87">    }</span>

    /*
       ADL 1.4
    */
    @Override
    @PostMapping(
            path = &quot;/adl1.4&quot;,
            produces = {MediaType.APPLICATION_XML_VALUE})
    @ResponseStatus(value = HttpStatus.CREATED)
    @EhrbaseAuthorization(permission = EhrbasePermission.EHRBASE_TEMPLATE_CREATE)
    public ResponseEntity createTemplateClassic(
            @RequestHeader(value = &quot;openEHR-VERSION&quot;, required = false) String openehrVersion, // TODO, see EHR-267
            @RequestHeader(value = &quot;openEHR-AUDIT_DETAILS&quot;, required = false)
                    String openehrAuditDetails, // TODO, see EHR-267
            @RequestHeader(value = CONTENT_TYPE) String contentType,
            @RequestHeader(value = ACCEPT, required = false) String accept,
            @RequestHeader(value = PREFER, required = false) String prefer,
            @RequestBody String template) {

        // TODO: only XML at the moment
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (!MediaType.parseMediaType(contentType).isCompatibleWith(APPLICATION_XML)) {</span>
<span class="nc" id="L109">            return ResponseEntity.status(HttpStatus.UNSUPPORTED_MEDIA_TYPE).body(&quot;Only XML is supported at the moment&quot;);</span>
        }

        TemplateDocument document;
        try {
<span class="nc" id="L114">            document =</span>
<span class="nc" id="L115">                    TemplateDocument.Factory.parse(new ByteArrayInputStream(template.getBytes(StandardCharsets.UTF_8)));</span>
<span class="nc" id="L116">        } catch (XmlException | IOException e) {</span>
<span class="nc" id="L117">            throw new InvalidApiParameterException(e.getMessage());</span>
<span class="nc" id="L118">        }</span>

<span class="nc" id="L120">        String templateId = templateService.create(document.getTemplate());</span>

<span class="nc" id="L122">        URI uri = createLocationUri(DEFINITION, TEMPLATE, ADL_1_4, templateId);</span>

<span class="nc" id="L124">        List&lt;String&gt; headerList = Arrays.asList(</span>
                LOCATION,
                ETAG,
                LAST_MODIFIED); // whatever is required by REST spec - CONTENT_TYPE only needed for 201, so handled
        // separately

        Optional&lt;InternalResponse&lt;ResponseData&gt;&gt;
                respData; // variable to overload with more specific object if requested

<span class="nc bnc" id="L133" title="All 2 branches missed.">        if (Optional.ofNullable(prefer)</span>
<span class="nc" id="L134">                .map(i -&gt; i.equals(RETURN_REPRESENTATION))</span>
<span class="nc" id="L135">                .orElse(false)) { // null safe way to test prefer header</span>
<span class="nc" id="L136">            respData = buildTemplateResponseData(templateId, accept, uri, headerList, () -&gt; new TemplateResponseData());</span>
        } else { // &quot;minimal&quot; is default fallback
<span class="nc" id="L138">            respData = buildTemplateResponseData(templateId, accept, uri, headerList, () -&gt; null);</span>
        }

        // TODO remove 204?
        // returns 201 with body + headers, 204 only with headers or 500 error depending on what processing above yields
<span class="nc" id="L143">        return respData.map(i -&gt; Optional.ofNullable(i.getResponseData())</span>
<span class="nc" id="L144">                        .map(j -&gt; ResponseEntity.created(uri)</span>
<span class="nc" id="L145">                                .headers(i.getHeaders())</span>
<span class="nc" id="L146">                                .body(j.get()))</span>
                        // when the body is empty
<span class="nc" id="L148">                        .orElse(ResponseEntity.noContent()</span>
<span class="nc" id="L149">                                .headers(i.getHeaders())</span>
<span class="nc" id="L150">                                .build()))</span>
                // when no response could be created at all
<span class="nc" id="L152">                .orElse(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build());</span>
    }

    // Note: based on latest-branch of 1.1.0 release of openEHR REST API, because this endpoint was changed
    // significantly
    @Override
    @GetMapping(&quot;/adl1.4&quot;)
    @EhrbaseAuthorization(permission = EhrbasePermission.EHRBASE_TEMPLATE_READ)
    public ResponseEntity getTemplatesClassic(
            @RequestHeader(value = &quot;openEHR-VERSION&quot;, required = false) String openehrVersion, // TODO, see EHR-267
            @RequestHeader(value = &quot;openEHR-AUDIT_DETAILS&quot;, required = false)
                    String openehrAuditDetails, // TODO, see EHR-267
            @RequestHeader(value = ACCEPT, required = false) String accept) {

<span class="nc" id="L166">        URI uri = createLocationUri(DEFINITION, TEMPLATE, ADL_1_4);</span>

        List&lt;String&gt; headerList =
<span class="nc" id="L169">                Collections.emptyList(); // whatever is required by REST spec - CONTENT_TYPE only needed for 201, so</span>
        // handled
        // separately

<span class="nc" id="L173">        Optional&lt;InternalResponse&lt;ResponseData&gt;&gt; respData =</span>
<span class="nc" id="L174">                buildTemplateResponseData(&quot;&quot;, accept, uri, headerList, () -&gt; new TemplatesResponseData());</span>

        // returns 200 with all templates OR error
<span class="nc" id="L177">        return respData.map(i -&gt; ResponseEntity.ok()</span>
<span class="nc" id="L178">                        .headers(i.getHeaders())</span>
<span class="nc" id="L179">                        .body(i.getResponseData().get()))</span>
<span class="nc" id="L180">                .orElse(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build());</span>
    }

    // Note: based on latest-branch of 1.1.0 release of openEHR REST API, because this endpoint was changed
    // significantly
    @Override
    @GetMapping(&quot;/adl1.4/{template_id}&quot;)
    @EhrbaseAuthorization(permission = EhrbasePermission.EHRBASE_TEMPLATE_READ)
    public ResponseEntity getTemplateClassic(
            @RequestHeader(value = &quot;openEHR-VERSION&quot;, required = false) String openehrVersion, // TODO, see EHR-267
            @RequestHeader(value = &quot;openEHR-AUDIT_DETAILS&quot;, required = false)
                    String openehrAuditDetails, // TODO, see EHR-267
            @RequestHeader(value = ACCEPT, required = false) String accept,
            @PathVariable(value = &quot;template_id&quot;) String templateId) {

<span class="nc" id="L195">        URI uri = createLocationUri(DEFINITION, ADL_1_4, templateId);</span>

<span class="nc" id="L197">        List&lt;String&gt; headerList = Arrays.asList(</span>
                LOCATION,
                ETAG,
                LAST_MODIFIED); // whatever is required by REST spec - CONTENT_TYPE only needed for 201, so handled
        // separately

<span class="nc" id="L203">        Optional&lt;InternalResponse&lt;ResponseData&gt;&gt; respData =</span>
<span class="nc" id="L204">                buildTemplateResponseData(templateId, accept, uri, headerList, () -&gt; new TemplateResponseData());</span>

<span class="nc" id="L206">        return respData.map(i -&gt; ResponseEntity.ok()</span>
<span class="nc" id="L207">                        .headers(i.getHeaders())</span>
<span class="nc" id="L208">                        .body(i.getResponseData().get()))</span>
<span class="nc" id="L209">                .orElse(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build());</span>
    }

    @GetMapping(path = &quot;/adl1.4/{template_id}/example&quot;)
    @EhrbaseAuthorization(permission = EhrbasePermission.EHRBASE_TEMPLATE_EXAMPLE)
    public ResponseEntity&lt;String&gt; getTemplateExample(
            @RequestHeader(value = ACCEPT, required = false) String accept,
            @PathVariable(value = &quot;template_id&quot;) String templateId) {
<span class="nc" id="L217">        CompositionFormat format = extractCompositionFormat(accept);</span>

<span class="nc" id="L219">        Composition composition = templateService.buildExample(templateId);</span>

<span class="nc" id="L221">        HttpHeaders respHeaders = new HttpHeaders();</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (format.equals(CompositionFormat.XML)) {</span>
<span class="nc" id="L223">            respHeaders.setContentType(APPLICATION_XML);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        } else if (format.equals(CompositionFormat.JSON)) {</span>
<span class="nc" id="L225">            respHeaders.setContentType(APPLICATION_JSON);</span>
        }

<span class="nc" id="L228">        return ResponseEntity.ok()</span>
<span class="nc" id="L229">                .headers(respHeaders)</span>
<span class="nc" id="L230">                .body(compositionService</span>
<span class="nc" id="L231">                        .serialize(new CompositionDto(composition, templateId, null, null), format)</span>
<span class="nc" id="L232">                        .getValue());</span>
    }

    /*
       ADL 2
       TODO WIP state only implements endpoints from outer server side, everything else is a stub. Also with a lot of duplication at the moment, which should be reduced when implementing functionality.
    */
    @Override
    @PostMapping(&quot;/adl2&quot;)
    @ResponseStatus(value = HttpStatus.CREATED)
    @EhrbaseAuthorization(permission = EhrbasePermission.EHRBASE_TEMPLATE_CREATE)
    public ResponseEntity&lt;TemplateResponseData&gt; createTemplateNew(
            @RequestHeader(value = &quot;openEHR-VERSION&quot;, required = false) String openehrVersion, // TODO, see EHR-267
            @RequestHeader(value = &quot;openEHR-AUDIT_DETAILS&quot;, required = false)
                    String openehrAuditDetails, // TODO, see EHR-267
            @RequestHeader(value = CONTENT_TYPE, required = false) String contentType,
            @RequestHeader(value = ACCEPT, required = false) String accept,
            @RequestHeader(value = PREFER, required = false) String prefer,
            @RequestParam(value = &quot;version&quot;, required = false) String version,
            @RequestBody String template) {

        // TODO implement handler - whole code below is only a stub yet

<span class="nc" id="L255">        TemplateResponseData data = new TemplateResponseData(); // empty for now</span>

<span class="nc" id="L257">        URI url = URI.create(&quot;todo&quot;);</span>
        // TODO - continuing stub but list of headers most likely the correct list of necessary ones
<span class="nc" id="L259">        HttpHeaders headers = new HttpHeaders();</span>
<span class="nc" id="L260">        headers.setContentType(APPLICATION_JSON);</span>
<span class="nc" id="L261">        headers.setLocation(url);</span>
<span class="nc" id="L262">        headers.setETag(&quot;\&quot;something...\&quot;&quot;);</span>
<span class="nc" id="L263">        headers.setLastModified(1234565778);</span>

<span class="nc" id="L265">        return Optional.ofNullable(data)</span>
<span class="nc" id="L266">                .map(i -&gt; new ResponseEntity&lt;&gt;(i, headers, HttpStatus.CREATED))</span>
<span class="nc" id="L267">                .orElse(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build());</span>
    }

    // TODO possible changes pending, keep an eye on: https://github.com/openEHR/specifications-ITS-REST/issues/85

    // Note: based on latest-branch of 1.1.0 release of openEHR REST API, because this endpoint was changed
    // significantly
    // also, this endpoint combines what is listed as two endpoints:
    // https://specifications.openehr.org/releases/ITS-REST/latest/definitions.html#definitions-adl-2-template-get
    @Override
    @GetMapping(&quot;/adl2/{template_id}/{version_pattern}&quot;)
    @EhrbaseAuthorization(permission = EhrbasePermission.EHRBASE_TEMPLATE_READ)
    public ResponseEntity&lt;TemplateResponseData&gt; getTemplateNew(
            @RequestHeader(value = &quot;openEHR-VERSION&quot;, required = false) String openehrVersion, // TODO, see EHR-267
            @RequestHeader(value = &quot;openEHR-AUDIT_DETAILS&quot;, required = false)
                    String openehrAuditDetails, // TODO, see EHR-267
            @RequestHeader(value = ACCEPT, required = false) String accept,
            @PathVariable(value = &quot;template_id&quot;, required = false) String templateId,
            @PathVariable(value = &quot;version_pattern&quot;, required = false) String versionPattern) {

        // TODO implement handler - whole code below is only a stub yet

        // TODO how to do that with multiple templates?
<span class="nc" id="L290">        TemplateResponseData data = new TemplateResponseData(); // empty for now</span>

<span class="nc" id="L292">        URI url = URI.create(&quot;todo&quot;);</span>
        // TODO - continuing stub but list of headers most likely the correct list of necessary ones
<span class="nc" id="L294">        HttpHeaders headers = new HttpHeaders();</span>
<span class="nc" id="L295">        headers.setContentType(APPLICATION_JSON);</span>
<span class="nc" id="L296">        headers.setLocation(url);</span>
<span class="nc" id="L297">        headers.setETag(&quot;\&quot;something...\&quot;&quot;);</span>
<span class="nc" id="L298">        headers.setLastModified(1234565778);</span>

<span class="nc" id="L300">        return Optional.ofNullable(data)</span>
<span class="nc" id="L301">                .map(i -&gt; new ResponseEntity&lt;&gt;(i, headers, HttpStatus.CREATED))</span>
<span class="nc" id="L302">                .orElse(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build());</span>
    }

    /**
     * Builds response data for template endpoints. As specified there are two kinds of returns, with one or all templates.
     * Hence factory can work with TemplateResponseData or TemplatesResponseData.
     *
     * @param templateId ID of the template, can be empty (&quot;&quot;) when all templates are requested
     * @param accept     Format the response should be delivered in, as given by request
     * @param uri        Location of resource
     * @param headerList List of headers to be set for response
     * @param factory    Works with TemplateResponseData or TemplatesResponseData
     * @param &lt;T&gt;        Type of response body
     * @return
     */
    private &lt;T&gt; Optional&lt;InternalResponse&lt;T&gt;&gt; buildTemplateResponseData(
            String templateId, String accept, URI uri, List&lt;String&gt; headerList, Supplier&lt;T&gt; factory) {
        // create either TemplateResponseData or null (means no body, only headers incl. link to resource), via lambda
        // request
<span class="nc" id="L321">        T oneOrAllTemplates = factory.get();</span>

        // do minimal scope steps
        // create and supplement headers with data depending on which headers are requested
<span class="nc" id="L325">        HttpHeaders respHeaders = new HttpHeaders();</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        for (String header : headerList) {</span>
<span class="nc bnc" id="L327" title="All 4 branches missed.">            switch (header) {</span>
                case LOCATION:
<span class="nc" id="L329">                    respHeaders.setLocation(uri);</span>
<span class="nc" id="L330">                    break;</span>
                case ETAG:
<span class="nc" id="L332">                    respHeaders.setETag(&quot;\&quot;&quot; + templateId + &quot;\&quot;&quot;);</span>
<span class="nc" id="L333">                    break;</span>
                case LAST_MODIFIED:
                    // TODO should be VERSION.commit_audit.time_committed.value which is not implemented yet - mock for
                    // now
<span class="nc" id="L337">                    respHeaders.setLastModified(123124442);</span>
<span class="nc" id="L338">                    break;</span>
                default:
                    // Ignore header
            }
<span class="nc" id="L342">        }</span>

        // parse and set accepted format. with XML as fallback for empty header and error for non supported header
<span class="nc" id="L345">        MediaType mediaType = resolveContentType(accept, MediaType.APPLICATION_XML);</span>
        OperationalTemplateFormat format;
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (mediaType.isCompatibleWith(MediaType.APPLICATION_XML)) {</span>
<span class="nc" id="L348">            format = OperationalTemplateFormat.XML;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        } else if (mediaType.isCompatibleWith(MediaType.APPLICATION_JSON)) {</span>
<span class="nc" id="L350">            format = OperationalTemplateFormat.JSON;</span>
        } else {
<span class="nc" id="L352">            throw new NotAcceptableException(&quot;Currently only xml (or emtpy for fallback) is allowed&quot;);</span>
        }

        // is null when request wants only metadata returned, so skips provisioning of body if null
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (oneOrAllTemplates != null) {</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">            if (oneOrAllTemplates.getClass().equals(TemplateResponseData.class)) { // get only one template</span>
                // when this &quot;if&quot; is true the following casting can be executed and data manipulated by reference
                // (handled by temporary variable)
<span class="nc" id="L360">                TemplateResponseData objByReference = (TemplateResponseData) oneOrAllTemplates;</span>

                // TODO very simple now, needs more sophisticated templateService
<span class="nc" id="L363">                String template = templateService.findOperationalTemplate(templateId, format);</span>
<span class="nc" id="L364">                objByReference.set(template);</span>

                // finally set last header // TODO only XML for now
<span class="nc" id="L367">                respHeaders.setContentType(APPLICATION_XML);</span>

<span class="nc bnc" id="L369" title="All 2 branches missed.">            } else if (oneOrAllTemplates.getClass().equals(TemplatesResponseData.class)) { // get all templates</span>
<span class="nc" id="L370">                TemplatesResponseData objByReference = (TemplatesResponseData) oneOrAllTemplates;</span>

<span class="nc" id="L372">                List&lt;TemplateMetaDataDto&gt; templates = templateService.getAllTemplates();</span>
<span class="nc" id="L373">                objByReference.set(templates);</span>
<span class="nc" id="L374">            } else</span>
<span class="nc" id="L375">                throw new InternalServerException(</span>
                        &quot;Building template response data failed&quot;); // i.e. wrong usage of buildTemplateResponseData()
        }

<span class="nc" id="L379">        return Optional.of(new InternalResponse&lt;&gt;(oneOrAllTemplates, respHeaders));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>